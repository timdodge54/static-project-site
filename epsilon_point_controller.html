<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epsilon Point Controller</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it-katex/dist/markdown-it-katex.min.js"></script>
</head>
<body class="bg-light">
    <header class="bg-dark text-white py-4 mb-5">
        <div class="container">
            <h1 class="display-4">Epsilon Point Controller of Smooth Differential Drive Model</h1>
        </div>
    </header>

    <main class="container">
        <div id="markdown-content"></div>

        <script type="text/markdown" id="markdown-source">
            # Epsilon Point Control of the Smooth Differential Drive Model

    This is a repo that shows an example of epsilon point control of the smooth differential drive model. The controller is implemented in Python, and simulations are done in three forms. The first is a basic integration simulation to show that the system is working as expected. The second is a matplotlib animation of the system. The third is a simulation in Gazebo and ROS2.

    ## Introduction

    The unicycle model is a common state space representation to express a differential drive robot.
    The unicycle model state consists of its x and y positions $x_1, \, x_2$, its orientation $\phi$,
    its forward velocity $\upsilon$, and its angular velocity $\omega$. This state expressed in vector form is then:

    ```math
    x = \begin{bmatrix} x_1 \\ x_2\\ \phi\\ \upsilon\\ \omega\end{bmatrix}
    ```

    The dynamics of this system are then defined by $\frac{d}{dx}$ which are expressed by:

    ```math
    \dot{x} = \begin{bmatrix}\upsilon\cos{\phi}\\  \upsilon \sin{\phi}\\ \omega \\ a \\ \alpha \end{bmatrix}
    ```

    ## Why Epsilon Point Control

    The difficulty with controlling this system is that it contains what are called "non-holonomic" constraints, which are non-integrable. The constraint with this system is that it cannot move orthogonal to its current orientation. To alleviate this, we utilize something called epsilon point control. The basic idea is that if a robot is traveling on a path, there is a point $\epsilon$ away that does not have that constraint. Instead of trying to control the robot's position, we control the position of this point.

    ## Math (You can skip this if you want but it is cool!)

    ### Definition of Epsilon State

    We can define the point that is $\epsilon$ away as $y_\epsilon$.

    ```math
    y_\epsilon = \begin{bmatrix}x_1\\ x_2\end{bmatrix} + \epsilon \begin{bmatrix}\cos{\phi}\\\sin{\phi}\end{bmatrix}
    ```

    To get the full state, we must also take the first and second derivatives of $y_\epsilon$.

    ```math
    R_{\epsilon} = \begin{bmatrix} \cos{\phi} & - \epsilon\sin{\phi} \\ \sin{\phi} & \epsilon\cos{\phi}\end{bmatrix}, \chi_\epsilon = \begin{bmatrix} 0 & - \epsilon\omega \\ \epsilon\omega & 0  \end{bmatrix}, \, \bar{a} = \begin{bmatrix}a\\ \alpha\end{bmatrix}, \, \bar{\upsilon} = \begin{bmatrix}\upsilon\\ \omega\end{bmatrix}
    ```

    ```math
    \dot{y}_\epsilon = R_{\epsilon}\bar{\upsilon}, \, \ddot{y}_\epsilon = R_{\epsilon} \chi_\epsilon\bar{\upsilon} + R_{\epsilon}\bar{a}
    ```

    ### Feedback Linearization

    $\ddot{y}_\epsilon$ is a function of $\bar{a}$, which are the control inputs of the system, so solving for this will give us the control inputs that will allow us to follow a path.

    ```math
    \bar{a} = R_{\epsilon}^{-1}(\ddot{y}_\epsilon - R_{\epsilon} \chi_\epsilon\bar{\upsilon})
    ```

    Using this, we can create a feedback linearized system.

    ```math
    \begin{bmatrix}\dot{y}_\epsilon \\ \ddot{y}_\epsilon\end{bmatrix} = Ay + Bu, \text{ where } y = \begin{bmatrix}y_\epsilon \\ \dot{y}_\epsilon \end{bmatrix}
    ```

    ```math
    \dot{y} = \begin{bmatrix}
    0 & 0 & 1 & 0\\
    0 & 0 & 0 & 1\\
    0 & 0 & 0 & 0\\
    0 & 0 & 0 & 0
    \end{bmatrix}y + \begin{bmatrix}
    0 & 0\\
    0 & 0\\
    1 & 0\\
    0 & 1\end{bmatrix}u
    ```

    ### Finding Control Gains for the System

    Now that we have a linearized system, we can find the control gains for the system. This can be done with either pole placement or LQR. Since we will eventually be controlling a TurtleBot3 robot, where the maximum linear velocity is 0.26 m/s and the maximum angular velocity is 1.82 rad/s, we use LQR to find the control gains. This lends itself to using Bryson's method to define our Q matrix. The gain matrix is found with the following.

    ```math
    k = lqr(A,B,Q,R), \text{ where } Q = \begin{bmatrix}1e-6 & 0 & 0 & 0\\
                                            0 &1e-6 & 0 & 0 \\
                                            0&0&\frac{1}{.26^2} & 0\\
                                            0 & 0 & 0 & \frac{1}{1.86^2}
                                     \end{bmatrix},  R = I \in \mathbb{R}^2
    ```

    The control input for the linearized system is then

    ```math
    u_y = u_{ff} - k (y - y_{des})
    ```

    ```math
    u_{ff} = \ddot{y}_\epsilon
    ```

    $y_{des}$ is the desired state of the system.

    This control can then be converted to the control for the unicycle model by the following equations.

    ```math
    \begin{bmatrix}a\\ \alpha\end{bmatrix} = R_{\epsilon}^{-1} u_y - \hat{\omega}\bar{v}
    ```

    ### Converting Unicycle to Smooth Differential Drive

    The unicycle model is not the most realistic model of a differential drive robot. In reality, we need to control the rotation for each of the robot's wheels. The smooth differential drive model is similar to the unicycle model but just swaps the velocity terms for left and right wheel velocities. The smooth differential drive model is defined by the following equations.

    ```math
    \dot{x} = \begin{bmatrix}
           \frac{r}{2}(w_r+w_t)\cos(\theta)\\
           \frac{r}{2}(w_r+w_t)\sin{\theta}\\
           \frac{r}{L}(w_r-w_l)\\
           u_r\\
           u_l
       \end{bmatrix}, \, \begin{bmatrix}
           v = \frac{r}{2}(w_r + w_l)\\
           w = \frac{r}{L}(w_r-w_l)
       \end{bmatrix},\, x = \begin{bmatrix}
           q_1\\
           q_2\\
           \theta\\
           w_r\\
           w_l
       \end{bmatrix}
    ```

    Skipping some algebra, the control inputs for the smooth differential drive model are

    ```math
    u_r = \frac{a}{r} - \frac{L}{2r}\alpha, \, u_l = \frac{a}{r} + \frac{L}{2r}\alpha
    ```

    ## Trajectory Tracking

    Trajectory tracking is done by defining the desired state of the $y_\epsilon$ system and finding its first and second derivatives. For this simulation, the chosen trajectory is

    ```math
    y = \begin{bmatrix}x_1\\x_2\end{bmatrix} = \begin{bmatrix}\sin{t}\\t\end{bmatrix}
    ```
        </script>
    </main>

    <footer class="bg-dark text-white py-4 mt-5">
        <div class="container text-center">
            <p>&copy; 2024 Epsilon Point Controller Project</p>
        </div>
    </footer>

    <script>
      window.onload = function() {
        // Initialize markdown-it with GitHub Flavored Markdown options
        var md = window.markdownit({
          html: true,
          linkify: true,
          typographer: true,
        }).use(window.markdownitKatex);

        // Get Markdown content from script tag
        var markdownContent = document.getElementById('markdown-source').innerHTML;
        // Convert Markdown to HTML
        var htmlContent = md.render(markdownContent);
        // Set the inner HTML of the container to the converted HTML content
        document.getElementById('markdown-content').innerHTML = htmlContent;
      };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
